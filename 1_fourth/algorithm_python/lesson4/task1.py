# Проанализировать скорость и сложность одного любого алгоритма, разработанных в рамках домашнего задания первых трех уроков.

# Для оценки сложности возьмем 2 задачу 3 урока.

# Во втором массиве сохранить индексы четных элементов первого массива.
# Например, если дан массив со значениями 8, 3, 15, 6, 4, 2, то во второй массив надо заполнить
# значениями 1, 4, 5, 6 (или 0, 3, 4, 5 - если индексация начинается с нуля),
# т.к. именно в этих позициях первого массива стоят четные числа.

# lst = [8, 3, 84, 15, 6, 4, 2]  такой список был изначально. Увеличим его примерно в 1000 раз
import random
import cProfile

def task():
    lst = []
    for i in range(1000000):
        lst.append(random.randrange(1000)) # данная операция имеет сложность O(1)

    lstIndex = []

    for e, number in enumerate(lst):    # данная операция имеет сложность O(N) 
        if number % 2 == 0:
            lstIndex.append(e)          # данная операция имеет сложность O(1)
    return lstIndex

cProfile.run('task()')

# изменяя количество элементов в списке можно увидеть как линейно меняется время поиска четных элементов списка
# Итого максимальная сложность для данного алгоритма O(N)